<!DOCTYPE html>
<html>
  <head>
    <title>Rust Smart Pointers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <style type="text/css" media="screen">
      img {
        max-width: 100%;
        max-height: 100%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: middle, center

# Rust Smart Pointers

### æœ€ç‡’è…¦çš„æ™ºæ…§æŒ‡æ¨™

<img 
  style="border-radius: 50px"
  src="https://www.gravatar.com/avatar/67644641ead7ae60a795a14b7e102973?s=100" 
  alt="Weihang Lo">

<a href="https://github.com/weihanglo">@weihanglo</a>

---

# Outline

- What is a pointer?

- What are "Smart Pointers"?

- Smart pointers in standard library

- Smart pointers in the wild

---

# What is a pointer?

An object storing the **memory address** of **a value** located in computer memory.

A pointer is able to **obtain the stored value** at that memory location, a.k.a **dereference**.

<img src="rust-smart-pointers/layout-1.png" width="500px" />

---

# What is a pointer in Rust?

```rust
let mut value = 1u8;

// create a mutable pointer (reference) to the value
let ptr = &mut value;

// deferences the pointer (obtains underlying value)
*ptr += 2;

// original value has changed!
assert_eq!(value, 3);
```

---

# What is a pointer in Rust?

1. There is a type called "[Reference][primitive-reference]".

2. References are **first-class values** in Rust.  
  
  That means they can be moved, copied, stored in struct and returned from functions.

3. Can be either **immutable** or **mutable** to the value referenced to.
  - shared (immutable) references (`&`)
  - mutable refernces (`&mut`)

4. Shared references impl [`Copy`][trait-copy] trait: copying itself, a.k.a **shallow copy**. 

5. Mutable references do not impl `Copy` trait to prevent creating multiple writable aliases.

> Pointer, reference and borrow are interchangeable in most cases in Rust.

[primitive-reference]: https://doc.rust-lang.org/std/primitive.reference.html
[trait-copy]: https://doc.rust-lang.org/std/marker/trait.Copy.html

---

# What are "Smart Pointers"?

- A data structure that simulates the behavior of a normal pointer.

- Providing additional features, such as
  - disposing resources when a pointer goes out of scope
  - allocating data on the heap
  - automatic memory management

- Also known as "**Fat Pointer**" for storing additional metadata such as capacity, reference counts.

- Not smart enough to be an artifical intelligence.

---

## What are "Smart Pointers" in Rust?

- ç‰¹æ®Šçš„è³‡æ–™çµæ§‹ï¼Œæ¨¡æ“¬ä¸€èˆ¬æŒ‡æ¨™çš„è¡Œç‚ºã€‚
- æä¾›è¨±å¤šé¡å¤–çš„åŠŸèƒ½ã€‚
  - éƒ¨åˆ†æ™ºæ…§æŒ‡æ¨™å¯å‹•æ…‹é…ç½®è¨˜æ†¶é«”ï¼ˆDynamic allocationï¼‰ã€‚
  - éƒ¨åˆ†æ™ºæ…§æŒ‡æ¨™å°è£ immutable data å¾Œï¼Œä»å¯ä»¥åœ¨ runtime ä¿®æ”¹å…¶å€¼ã€‚
- åˆç¨±ã€Œèƒ–æŒ‡æ¨™ã€ï¼Œå› ç‚ºå„²å­˜æŒ‡å‘è³‡æ–™çš„æŒ‡æ¨™å¤–ï¼Œé€šå¸¸æœƒå„²å­˜é¡å¤–è³‡è¨Šï¼Œä¾‹å¦‚é™£åˆ—é•·åº¦ï¼Œç©ºé–“éœ€æ±‚ç¨å¤§ã€‚

<img src="rust-smart-pointers/layout-2.png" width="400px" />

---

## å¦‚ä½•ä½¿ç”¨ `struct` æ¨¡æ“¬æŒ‡æ¨™

å¿…é ˆåšåˆ°å…©ä»¶äº‹ï¼š

- ç¢ºèª dereference æ™‚å¯è§£é–‹å¼•ç”¨ï¼Œå–å¾—åº•å±¤å€¼ -> å¯¦ä½œ `Deref` trait

- ç¢ºèªæŒ‡æ¨™çµæŸç”Ÿå‘½é€±æœŸæ™‚ï¼Œæœƒæ­£ç¢ºé‡‹æ”¾è³‡æº -> å¯¦ä½œ `Drop` trait

ç¬¦åˆä¸Šè¿°è¦ä»¶ï¼Œä¸¦åœ¨ safe Rust å‰æä¸‹å¯¦ä½œçš„æ™ºæ…§æŒ‡æ¨™ï¼Œå°±å¯æ¶ˆå¼­çµ•å¤§å¤šæ•¸è¨˜æ†¶é«”å•é¡Œï¼Œä¾‹å¦‚ double free æˆ– wild pointerã€‚

> **Smart Pointer in Rust ï¼ Data structure + Deref + Drop**

---

## `Deref` trait

- ç”¨ä¾†å¤šè¼‰è§£å¼•ç”¨é‹ç®—å­ `*`ï¼ˆdereferenceï¼‰çš„ traitã€‚
- æœ‰ä¸€å€‹ required method `fn deref(&self) -> &Self::Target`
- `DerefMut` å‰‡æ˜¯ç”¨åœ¨ `&mut` çš„ dereferenceã€‚
- Rust æœ‰å¾ˆå¤š implicit dereferenceï¼Œå¯¦ä½œ `Deref` trait æœƒè®“ç”Ÿæ´»å¥½éå¾ˆå¤šã€‚

```rust
pub trait Deref {
    /// The resulting type after dereferencing.
    type Target: ?Sized;

    /// Dereferences the value.
    fn deref(&self) -> &Self::Target;
}
```

```rust
use std::ops::Deref;

fn main() {
    let s = &1u8;
    assert_eq!(&1, s);
    assert_eq!(1, *s);
    assert_eq!(&1, s.deref()); // fn deref() -> &u8
}
```

---

## Implicit dereference

ç‚ºäº†è®“å¤§å®¶æ–¹ä¾¿å¯« codeï¼Œä¸ç”¨å†å€åˆ† `obj.method`ã€`obj->method`ã€`(*obj).method`ï¼ŒRust å¹«æˆ‘å€‘çµ±ä¸€ä»‹é¢ï¼Œåªè¦æ˜¯å‡½æ•¸å‚³åƒæˆ–æ–¹æ³•å‘¼å«ï¼Œç•¶

- å°æŒ‡å‘ value type çš„æŒ‡æ¨™æ“ä½œæ™‚ï¼Œå°±åŸ·è¡ŒåŸæœ¬çš„å‹•ä½œã€‚
- è¶…éä¸€å±¤æŒ‡æ¨™åŒ…è£¹ value æ™‚ï¼Œæœƒå…ˆå‘¼å« `obj.deref()`ï¼Œå°‡ `T` å¼•ç”¨è§£ç‚º `U` çš„å€¼ã€‚

```rust
use std::ops::Deref;

fn main() {
    let s = &String::from("123");
    assert_eq!(3, s.len());
    assert_eq!(3, s.deref().len());
    assert_eq!(3, (&s).len()); // s.deref().deref()
    assert_eq!(3, (&&s).len()); // s.deref().deref().deref()
    assert_eq!(3, (&&&&&&s).len()); // s.deref().deref().deref()...
}
```

---

## `Drop` trait

- å¯è¦–ç‚º destructor ææ§‹å‡½æ•¸ï¼Œç•¶ value é›¢é–‹ scope å‘¼å«ï¼Œå¯ç”¨ä¾†é‡‹æ”¾è³‡æºã€‚
- ç‚º [RAII pattern][wiki-raii] çš„è³‡æºç®¡ç†æ©Ÿåˆ¶ã€‚
- Rustc ä¸çµ¦ç›´æ¥å‘¼å« methodï¼Œè«‹ä½¿ç”¨ `std::mem::drop`ã€‚
- Rustc ä¸ä¿è­‰ä¸€å®šæœƒå‘¼å«ï¼ˆä¾‹å¦‚ FFI ä¸éœ€è¦ï¼‰ã€‚

```rust
let v = vec![1, 2, 3];
drop(v); // Explicitly drop.

{
    let v = vec![1, 2, 3];
}   // Implicitly drop. Call drop(&v) when v is out of scope.
```

[wiki-raii]: https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization

---

## `std` çš„æ™ºæ…§æŒ‡æ¨™

- `Box`
- `Rc`
- `Arc`
- `Cell`
- `RefCell`
- `Mutex`
- `RwLock`
- `Atomic*`
- `Vec`
- `String`
- åœ¨ `std::collections` çš„é›†åˆå‹åˆ¥ 
- [æŸ¥çœ‹æ›´å¤š...](#)

---

## è¨˜æ†¶é«”é…ç½®

<img src="rust-smart-pointers/rust-container-cheat-sheet.png" width="800px" />

.center[Raph Levien, Google. CC BY]

---

## è¨˜æ†¶é«”é…ç½® - åœ–ä¾‹

<img src="rust-smart-pointers/legend.png" width="300px" />

---

## `Box` ğŸ“¦

åœ¨ heap ä¸Šé…ç½®ç©ºé–“å„²å­˜ owned contentã€‚

- æŒ‡å‘ heap ä¸Šçš„è³‡æ–™ï¼Œ`Box` æœ¬èº«é…ç½®åœ¨ stack ä¸Šï¼Œä½” 1 `usize` çš„ç©ºé–“ã€‚
- ä¿æœ‰ content çš„ ownershipï¼Œ`Box` ç”Ÿå‘½é€±æœŸçµæŸæœƒ drop å®ƒçš„ contentã€‚
- æ˜¯æœ€æ³›ç”¨çš„æ™ºæ…§æŒ‡æ¨™ã€‚
- é¡ä¼¼ C++ `std::unique_ptr`ã€‚

```rust
pub struct Box<T: ?Sized>(Unique<T>);

impl<T> Box<T> {
    pub fn new(x: T) -> Box<T> {
        box x
    }
}
```

---

## è¨˜æ†¶é«”é…ç½®

<img src="rust-smart-pointers/box-layout.png" width="250px" />

---

## ç°¡å–®æ“ä½œ

å°‡å€¼æ”¾åˆ° heap ä¸Š

```rust
let val = 5u8;
let boxed = Box::new(val);
```

dereference è§£å¼•ç”¨

```rust
let boxed = Box::new(5u8);
let val = *boxed;
```

implict deref ç¯„ä¾‹

```rust
fn implicit_deref(a: &u8) { dbg!(a); }
let boxed = Box::new(5u8);
implicit_deref(&boxed); // a = 5
```

---

## `Box` èˆ‡ dispatch

- Direct (static) dispatch
- Table dispatch
- Message dispatch

<img src="rust-smart-pointers/dyn-trait-layout.png" width="400px" />

---

## ä»€éº¼æ™‚å€™è©²ç”¨ `Box`

âœ… ä½ éœ€è¦å„²å­˜ recursive typeï¼Œç„¡æ³•éœæ…‹æ±ºå®šå‹åˆ¥å¤§å°

âœ… ä½ éœ€è¦è½‰ç§»è³‡æ–™çš„æ‰€æœ‰æ¬Šä½†æƒ³é¿å…æ•´å€‹è¤‡è£½

âœ… ä½ éœ€è¦å°‡è³‡æ–™é…ç½®åœ¨ heap ä¸Š

âœ… ä½ éœ€è¦ä¸€å€‹ null pointerï¼ˆ`Option<Box<T>>`ï¼‰

âœ… ä½ æƒ³å¯«ç°¡å–®çš„ singly linked list

âœ… ä½ éœ€è¦åš dynamic dispatchï¼Œä¾‹å¦‚ `dyn` Traitï¼ˆformer Trait Objectï¼‰

âŒ ä½ æƒ³æ‰¾å€‹ç°¡å–®çš„æ™ºæ…§æŒ‡æ¨™ä¾†å­¸ï¼ˆæœƒçœ‹åˆ°ç¥å¥‡çš„ `box` keyword ğŸ¤¯ï¼‰

---

## `Cell` èˆ‡ `RefCell` ğŸ“¦ ğŸ’µ ğŸ© ğŸ‡

ç”¨ä¾†æ‰“ç ´ borrow checker çš„ã€Œå…±äº«ä¸å¯è®Šï¼Œå¯è®Šä¸å…±äº«ã€è¦å‰‡ã€‚è®“ immutable reference ä¹Ÿèƒ½ä¿®æ”¹ã€‚

- å…©è€…ä¿®æ”¹ immutable reference æ˜¯é€éã€Œinterior mutabilityã€ã€‚
  - `Cell` é€éæ‰€æœ‰æ¬Šè½‰ç§»ä¿®æ”¹å…§éƒ¨çš„ valueã€‚
  - `RefCell` è—‰ç”± runtime borrow checker æ“ä½œæŒ‡æ¨™ã€‚
- å…©è€…çš†ä¸æœƒé¡å¤–åœ¨ heap é…ç½®ç©ºé–“å­˜è³‡æ–™ã€‚

<img src="rust-smart-pointers/cell-layout.png" />

---

## Inherited and Interior Mutability

**Inherited mutability**

ä¸€å€‹è³‡æ–™çµæ§‹å…§éƒ¨æ¬„ä½çš„å¯è®Šæ€§å–æ±ºæ–¼ã€Œè®Šæ•¸æ˜¯å¯è®Šçš„ binding æˆ–æ˜¯ä¸è®Šçš„ bindingã€ã€‚å¯è®Šæ€§ä¸€æ—¦æ±ºå®šå°±æœƒæ ªé€£ä¹æ—ï¼Œæ¯å€‹æ¬„ä½éƒ½æœƒã€Œç¹¼æ‰¿ã€ç›¸åŒçš„å¯è®Šæ€§ã€‚

```rust
struct S(u8);
let mut s1 = S(1);
s1.0 += 2; // s1 is mutable, so s1.0 is also mutable.

let s2 = S(1);
s2.0 += 2; // Compile failed. s2 is immutable.
```

**Interior mutability**

è‹¥ä¸€å€‹å‹åˆ¥å¯ä»¥é€é shared reference ä¾†ä¿®æ”¹å…¶å…§éƒ¨ç‹€æ…‹ï¼Œå‰‡æˆ‘å€‘ç¨±ä¹‹æœ‰ Interior mutability ï¼Œé€™æœƒé€é `UnsafeCell<T>` é€™å€‹é»‘ç›’å­å¯¦ä½œã€‚

> `UnsafeCell` æ˜¯ safe Rust ä¸­å°‘æ•¸å¯ä»¥ç„¡è¦–ã€Œå…±äº«ä¸å¯è®Šï¼Œå¯è®Šä¸å…±äº«ã€çš„å‹åˆ¥ï¼Œ`Cell` èˆ‡ `RefCell` éƒ½æ˜¯å…¶è¡ç”Ÿå‹åˆ¥ã€‚

---

## `Cell` çš„å…§éƒ¨å¯¦ä½œ

`Cell` çš„çµæ§‹é«”ä¸åŒ…å«å…¶ä»– metadataï¼Œç›´æ¥å°±æ˜¯é€é `UnsafeCell` å„²å­˜ valueã€‚

```rust
pub struct Cell<T: ?Sized> {
    value: UnsafeCell<T>,
}
```

<img src="rust-smart-pointers/cell-layout.png" />

---

## `Cell` çš„ API

`Cell` å°ä¸åŒå‹åˆ¥çš„æ“ä½œç¶­æŒä¸€å€‹å…±è­˜ï¼šã€Œ**è½‰ç§»æ•´å€‹è³‡æ–™çš„æ‰€æœ‰æ¬Š**ã€ã€‚ä¾‹å¦‚ `get`ã€`set` çš†æ˜¯ç›´æ¥ copy æˆ–æ˜¯å–ä»£åŸæœ¬çš„å€¼ã€‚

```rust
use std::cell::Cell;

let c = Cell::new(5);

c.set(10); // discard 5 and value set to 10
c.get();  // 10 (a copy but not a reference)
c.replace(7) // 10 (returns the replaced value)
```

---

## `RefCell` çš„å…§éƒ¨å¯¦ä½œ

`RefCell` æ˜¯æœƒå‹•æ…‹æª¢æŸ¥ borrow checker rule çš„å‹åˆ¥ï¼Œæ¯” `Cell` å¤šä¸€å€‹ `borrow` çš„æ¬„ä½ï¼Œå‹•æ…‹ç´€éŒ„å¼•ç”¨çš„æƒ…å½¢ã€‚

```rust
pub struct RefCell<T: ?Sized> {
    borrow: Cell<BorrowFlag>, // 
    value: UnsafeCell<T>,
}
```

<img src="rust-smart-pointers/cell-layout.png" />

---

## `RefCell` çš„ API

`RefCell` æä¾› `borrow_mut()` èˆ‡ `borrow()` å…©å€‹æ–¹æ³•ï¼Œå‹•æ…‹ç”¢ç”Ÿä¸åŒçš„ referenceã€‚

```rust
use std::cell::RefCell;

let c = RefCell::new(5); // create a RefCell
*c.borrow_mut() += 5;   // mutably borrow and mutate interior value
assert_eq!(&*c.borrow(), &10); // immutably borrow to check the value
```

æ¯”è¼ƒç‰¹åˆ¥çš„æ˜¯ï¼Œ`RefCell::borrow` èˆ‡ `RefCell:borrow_mut` çš„å›å‚³å€¼ä¸¦é `&T` èˆ‡ `&mut T`ï¼Œè€Œæ˜¯å¸¶æœ‰å¯¦ä½œç´°ç¯€çš„ `Ref<T>` èˆ‡ `RefMut<T>`ã€‚é€™å€‹ç‰¹æ€§è®“ `RefCell` ç„¡æ³•è¨­è¨ˆå‡ºå‡½å¼åº«ç­‰ç´šçš„å„ªç¾ä»‹é¢ï¼Œåè€Œæ›´é©åˆ application å±¤çš„å¯¦éš›æ‡‰ç”¨ã€‚

---

## ä»€éº¼æ™‚å€™è©²ç”¨ `Cell` æˆ– `RefCell` 

âœ… ä½ éœ€è¦ä¸€å€‹å°å¤– immutableï¼Œä½†å…§éƒ¨ç‹€æ…‹å¯è®Šçš„è³‡æ–™çµæ§‹

âœ… ä½ éœ€è¦å‹•æ…‹å»ºç«‹å¤šå€‹å¯è®Šçš„ alias

âœ… ä½ æƒ³è¦è®Šæ›´ `Rc` å¤šå€‹æŒ‡æ¨™åº•å±¤çš„è³‡æ–™ç‹€æ…‹

âœ… ä½ æ·±ä¿¡ä½ çš„ç¨‹å¼ç¢¼å®Œå…¨æ­£ç¢ºï¼Œåªæ˜¯ Rust borrow checker å¤ªå‚»çœ‹ä¸æ‡‚ä½ çš„é‚è¼¯

âŒ ä½ å¸Œæœ›å¯«å‡ºä»‹é¢å„ªç¾çš„å‡½å¼åº«ï¼Œä¸è¦æ›éœ²ç´°ç¯€ï¼ˆ`RefCell`ï¼‰

---

## `Rc` â¡ï¸ ğŸ“¦ â¬…ï¸

å–®åŸ·è¡Œç·’çš„å¼•ç”¨è¨ˆæ•¸æŒ‡æ¨™ï¼Œç”¨ä¾†å…±äº«é…ç½®åœ¨ heap ä¸Šçš„è³‡æ–™ã€‚

- å…§éƒ¨ç´€éŒ„å¼•ç”¨è³‡æ–™çš„æŒ‡æ¨™æ•¸é‡ï¼Œç•¶æœ€å¾Œä¸€å€‹ `Rc` æŒ‡æ¨™éŠ·æ¯€æ™‚ï¼Œè³‡æ–™ä¹Ÿéš¨é¢¨è€Œå»ã€‚
- å› ç‚ºå…±äº«ï¼Œæ‰€ä»¥ç¦æ­¢ä»»ä½• mutationï¼ˆå¯å¾ interior mutability ç¹éï¼‰ã€‚
- å¯èƒ½ç™¼ç”Ÿå¾ªç’°å¼•ç”¨ï¼Œå°è‡´è¨˜æ†¶é«”æ´©æ¼ï¼Œè«‹æ„›ç”¨ `Weak` å¼±å¼•ç”¨ã€‚
- éåŸå­æ“ä½œï¼Œæ‰€ä»¥ç„¡æ³•åœ¨åŸ·è¡Œç·’é–“å‚³éï¼Œè«‹æ„›ç”¨ `Arc` åŸå­å¼•ç”¨è¨ˆæ•¸æŒ‡æ¨™ã€‚
- é¡ä¼¼ C++ `std::shared_ptr`ã€‚

```rust
pub struct Rc<T: ?Sized> {
    ptr: NonNull<RcBox<T>>,
    phantom: PhantomData<T>,
}

struct RcBox<T: ?Sized> {
    strong: Cell<usize>,
    weak: Cell<usize>,
    value: T,
}
```

---

## è¨˜æ†¶é«”é…ç½®

<img src="rust-smart-pointers/rc-layout.png" width="400px" />

---

## ç°¡å–®æ“ä½œ

å»ºç«‹ Rc ä¸¦å…±äº«å¼•ç”¨ï¼ˆè¤‡è£½ Rc pointerï¼‰

```rust
use std::rc::Rc;

let five = Rc::new(5);
let another_five = Rc::clone(&five);

assert_eq!(five, another_five);
```

å‡ç´š `Weak` -> `Rc` ï¼Œèˆ‡é™ç´š `Rc` -> `Weak` 

```rust
use std::rc::Rc;

let five = Rc::new(5);
let weak_five = Rc::downgrade(&five);

let strong_five: Option<Rc<_>> = weak_five.upgrade();
assert!(strong_five.is_some());
// Destroy all strong pointers.
drop(strong_five);
drop(five);

assert!(weak_five.upgrade().is_none());
```

---

## `Rc` å¦‚ä½•ç®¡ç† weak èˆ‡ strong reference

```rust
unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {
    fn drop(&mut self) {
        unsafe {
            self.dec_strong();
            if self.strong() == 0 {
                // destroy the contained object
                ptr::drop_in_place(self.ptr.as_mut());

                // remove the implicit "strong weak" pointer now that we've
                // destroyed the contents.
                self.dec_weak();

                if self.weak() == 0 {
                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));
                }
            }
        }
    }
}
```

---

## ä»€éº¼æ™‚å€™è©²ç”¨ `Rc`

âœ… ä½ éœ€è¦å…±äº«ä¸€å † aliasï¼Œä½†ä¸ç¢ºå®šå“ªå€‹ alias æœƒå…ˆçµæŸ

âœ… ä½ å¾ˆçª®ï¼Œä½†ä½ éœ€è¦ä¸€å€‹ GCï¼ˆ`Rc` + `RefCell` = çª®äººçš„ GCï¼‰

> `Rc` + `RefCell` = çª®äººçš„ GC

[åƒè€ƒè³‡æ–™ï¼šäº‹å¯¦ä¸Š Rust è‡ªå¸¶ static GCï¼Ÿï¼](https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis)

---

## `Cow` ğŸ“¦ âœï¸  ğŸ‘

**Clone On Write** çš„æ™ºæ…§æŒ‡æ¨™ï¼Œä¿®æ”¹æŒ‡æ¨™æŒ‡å‘çš„è³‡æ–™æ™‚ï¼Œæ‰æœƒè¤‡è£½ä¸€ä»½è³‡æ–™ã€‚

- `Cow` æ˜¯ä¸€å€‹ `enum`ï¼Œæœƒæ˜¯ borrowed æˆ– owned data å…¶ä¸­ä¸€ç¨®ã€‚
- `Cow<T>` çš„ `T` éœ€å¯¦ä½œ `ToOwned` traitï¼Œå¯è¦–ç‚ºéœ€è¦èƒ½è¢« cloneã€‚


```rust
pub enum Cow<'a, B: ?Sized + 'a>
    where B: ToOwned
{
    /// Borrowed data.
    Borrowed &'a B), 
    /// Owned data.
    Owned(<B as ToOwned>::Owned),
}
```

---

## è¨˜æ†¶é«”é…ç½®

<img src="rust-smart-pointers/enum-layout.png" />

---

## å¦‚ä½•ä½¿ç”¨ `Cow`

äº‹å¯¦ä¸Šï¼Œé™¤äº† trait implement å¤–ï¼Œ`Cow` åªæœ‰ `into_owned` èˆ‡ `to_mut` å…©å€‹æ–¹æ³•ã€‚

```rust
use std::borrow::Cow;

let s = "Hello world!";
let cow = Cow::Borrowed(s); // å¼•ç”¨ s

assert_eq!(
  cow.into_owned(),   // é€é `into_owned()` è½‰æ›æˆ owned data
  String::from(s)
);

let mut cow = Cow::Borrowed("foo");
cow.to_mut().make_ascii_uppercase(); // åˆ©ç”¨ to_mut() è¤‡è£½ä¸€ä»½è³‡æ–™

assert_eq!(
  cow,
  Cow::Owned(String::from("FOO")) as Cow<str> // å·²èˆ‡åŸå§‹è³‡æ–™ä¸åŒ
);
```

---

## ä»€éº¼æ™‚å€™è©²ç”¨ `Cow`

âœ… ä½ é‡åˆ° clone çš„æ•ˆèƒ½ç“¶é ¸ï¼Œå¸Œæœ›æ¸›å°‘ clone çš„æ¬¡æ•¸ã€‚

âœ… ä½ ä¸æƒ³è¦è™•ç†å¤šé‡æŒ‡æ¨™çš„å•é¡Œï¼Œä½†ä¹Ÿä¸æƒ³è¦å…¨éƒ¨éƒ½ cloneã€‚

âœ… ä½ æƒ³è¦é¿å… Mutex äº’æ–¥é–æ•ˆèƒ½ä¸å½°çš„å•é¡Œ

âœ… â€œPay only for what you use.â€ No mutation. No clone.

âŒ ä½ æ„Ÿåˆ°ä¸çˆ½æ™‚å¤§å–Š

---

## å…¶ä»–æœ‰è¶£çš„ç¤¾ç¾¤ crates

ğŸŸ [typed-arena][typed-arena]

æ›¾å‡ºç¾åœ¨ [Nightly][rust-1.1.0-arena] ä½†æœ€å¾Œè¢«ç§»é™¤çš„ [Region-based allocation][region-alloc] å¯¦ä½œã€‚æ‰€è¬‚ region-based allocation æŒ‡å°‡ç‰©ä»¶å»ºç«‹åœ¨é å…ˆé…ç½®çš„é€£çºŒè¨˜æ†¶é«”ç©ºé–“ï¼Œé€™äº›ç‰©ä»¶æœ€å¾Œæœƒä¸€èµ·é‡‹æ”¾è¨˜æ†¶é«”ç©ºé–“ã€‚é€™ç¨®ä½œæ³•å¯ä»¥è®“ alloc/dealloc æ›´å¿«ï¼Œä¸¦æå‡ cache æ•ˆèƒ½ã€‚ç”šè‡³å¯å¾ªç’°å¼•ç”¨ä½†ä¸æœƒè¨˜æ†¶é«”æ´©æ¼ï¼Œé©åˆå¯¦ä½œ graphã€tree ç­‰å¾ªç’°è³‡æ–™çµæ§‹ã€‚ 

ğŸ¤ [owning-ref][owning-ref]
 
å»ºç«‹åŒ…å« owned data ä½†å°å¤–ä»‹é¢æ˜¯ reference type çš„æ™ºæ…§æŒ‡æ¨™ã€‚

ğŸ¥‡ [once_cell][once_cell]

é¡ä¼¼ `RefCell`ï¼Œç‰¹è‰²æ˜¯å…è¨±å¤šæ¬¡è®€å–ä½†åƒ…èƒ½å¯«å…¥å”¯ä¸€ä¸€æ¬¡ã€‚é€™å€‹é™åˆ¶è®“ `OnceCell` å¯ä»¥å›å‚³ `&T` è€Œéé†œé™‹çš„ `Ref<T>`ã€‚ï¼ˆè²Œä¼¼é©åˆ singleton patternï¼‰

[typed-arena]: https://github.com/SimonSapin/rust-typed-arena
[region-alloc]: https://en.wikipedia.org/wiki/Region-based_memory_management
[rust-1.1.0-arena]: https://doc.rust-lang.org/1.1.0/arena/struct.TypedArena.html
[owning-ref]: https://github.com/Kimundi/owning-ref-rs
[once_cell]: https://github.com/matklad/once_cell

---

class: middle, center

## AMA Time!

We are from

<img src="https://hahow.in/static/media/logo-black.23fa8b87.svg" width="250px" alt="Hahow å¥½å­¸æ ¡" />

Ask us anything!

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
