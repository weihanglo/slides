<!DOCTYPE html>
<html>
  <head>
    <title>Rust Concurrency</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <style type="text/css" media="screen">
      img {
        max-width: 100%;
        max-height: 100%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: middle, center

# Rust Concurrency

### Multithreading å…é©šå•¦ï¼

<img 
  style="border-radius: 50px"
  src="https://www.gravatar.com/avatar/67644641ead7ae60a795a14b7e102973?s=100" 
  alt="Weihang Lo">

<a href="https://github.com/weihanglo">@weihanglo</a>

---

## Outline

- What is Concurrency
- Why Concurrency is Hard
- How to Control Concurrency
- Concurrency Model in Rust
  - Threading Model
  - `Send` and `Sync` Traits
  - Synchronization Primitives
  - Higher-level Synchronization Objects
- Patterns of Concurrent Programming
- References

---

class: middle, center

# What is Concurrency

---

### From Oxford Dicionary

**concurrent**

/kÉ™nËˆkÊŒr(É™)nt/

_adjective_

Existing, happening, or done at the same time.

âœ… at the same time

### From Wikipedia

...the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome.

âœ… executed out-of-order or in partial order

---

## Concurrency

- å¤šå€‹é‹ç®—å¯ä¾ä»»æ„é †åºåŸ·è¡Œã€‚
- æ¯å€‹é‹ç®—å¯ä»¥äº¤éŒ¯ï¼Œç”šè‡³é‡ç–Šã€‚
- Concurrent âŸº Sequential
- Concurrency â‰  Parallelism.

<img src="https://i.imgur.com/EWktsiL.png" width="500px">

---

class: middle, center

<img src="https://i.imgur.com/D3XxdDy.png" width="500px">

[By Omar Ferrer](https://omsface.com/post/parallel-parking/)

---

## Concurrency çš„å„ªé»

- **é™ä½ latency:** å·¥ä½œå¯ä»¥è¢«åˆ†æˆå°å–®å…ƒå†ä¸¦è¡Œé‹ç®—ã€‚

- **éš±è— latency**: long-running å¯ä»¥ä¸¦è¡Œé‹ç®—ï¼ˆä¾‹å¦‚ç£ç¢Ÿæˆ–ç¶²è·¯ I/O)ã€‚

- **å¢åŠ  throughput**: ä¸è€ƒæ…®å…¶ä»–é–‹éŠ·ï¼Œå¤§éƒ¨åˆ†ä¸¦è¡Œé‹ç®— throughout æœƒå¢åŠ ã€‚

---

class: middle, center

# Why Concurrency is Hard

![](https://i.imgur.com/oWNjKXf.jpg)

---

## Out-of-order Execution

- Compiler reorder instructions
  - Compiler æœƒæœ€ä½³åŒ–ï¼ŒåŸ·è¡Œ CPU æŒ‡ä»¤çœ‹èµ·ä¾†å°±æœƒå’Œç¨‹å¼ç¢¼é †åºä¸ä¸€è‡´ï¼Œä¾‹å¦‚å…ˆæŠŠè®€å–è¨˜æ†¶é«”æ¬åˆ° code block æœ€å‰é¢ï¼Œè®“ CPU å¯ä»¥ prefetch è¨˜æ†¶é«”ã€‚
  - å–®åŸ·è¡Œç·’çš„ç¨‹å¼ä¸­ä¹Ÿå¯èƒ½ç™¼ç”Ÿï¼Œä¾‹å¦‚å¯« signal æˆ– interrupt handler é€™ç¨® low-level ç¨‹å¼ã€‚
  - é€™æ¬¡ä¸ç´°è¬›ï¼Œæœ‰èˆˆè¶£è«‹åƒè€ƒ [Linux Kernel memory barriers][memory barriers]ã€‚

- Single processor ä¸‹çš„ [Out-of-order Executionï¼ˆOoOEï¼‰](https://en.wikipedia.org/wiki/Out-of-order_execution)
  - ä¸åŒæŒ‡ä»¤æ‰€éœ€åŸ·è¡Œæ™‚é–“é•·åº¦ä¸åŒï¼Œç•¶å‰å¹¾æ¢æŒ‡ä»¤å°šæœªå®Œæˆï¼Œå…¶ä»–æå‰å®Œæˆçš„ CPU æŒ‡ä»¤å°±æ˜¯ OoOEã€‚
  - Rust ç›®å‰ä¸è™•ç†é€™ç¨® concurrencyï¼Œç”± CPU è™•ç†ã€‚
  - Meltdown [å°±æ˜¯é€é OoOE ä¾†æ”»æ“Š][ntucc-meltdown]ã€‚

- Multiprocessor ä¸‹å¤šå€‹åŸ·è¡Œç·’åŒæ™‚åŸ·è¡Œï¼Œå°è‡´ä»¥éé æœŸçš„é †åºå­˜å–è³‡æºã€‚

[ntucc-meltdown]: http://www.cc.ntu.edu.tw/chinese/epaper/0045/20180620_4508.html
[memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt

---

## Data Race and Race Condition

- **Data Raceï¼š**å…©å€‹å­˜å–è¨˜æ†¶é«”çš„æ“ä½œåŒæ™‚
  1. å­˜å–åŒä¸€å€‹è¨˜æ†¶é«”ä½å€ï¼Œä¸¦ç”±å…©å€‹åŸ·è¡Œç·’åŸ·è¡Œ
  2. ä¸æ˜¯åªè®€æ“ä½œï¼Œä¹Ÿä¸æ˜¯åŒæ­¥æ“ä½œï¼ˆsynchronization operationsï¼‰

- **Race Conditionï¼š**ä¸åŒçš„ç¨‹å¼åŸ·è¡Œé †åºå½±éŸ¿è¼¸å‡ºçµæœï¼Œé€šå¸¸ç”±å¤–éƒ¨å½±éŸ¿ï¼Œä¾‹å¦‚ context switchã€OS signalã€hardware interrupt æˆ– multiprocessorã€‚

- Data Race å¯ä»¥å°è‡´ Race Conditionï¼Œä½†ä¸å¿…ç„¶ï¼›åä¹‹ Race Condition ä¹Ÿä¸ä¸€å®šç”± Data Race ç”¢ç”Ÿã€‚

> [Data Race vs Race Condition å°å“æ–‡][data-race-condition]

[data-race-condition]: https://blog.regehr.org/archives/490

---

![](https://cdn.dribbble.com/users/1218634/screenshots/3157258/knock-knock-race-condition-joke.png)

---

class: middle, center

# How to Control Concurrency

---

## Concurrency Control

- ç›®æ¨™ï¼šç¶­æŒæœ€çµ‚è¼¸å‡ºçš„æ­£ç¢ºæ€§ï¼Œä¸¦è¶Šå¿«è¼¸å‡ºè¶Šå¥½ã€‚
- æ‰‹æ®µï¼š
  1. åŒæ­¥ï¼ˆSynchronizationï¼‰ï¼šåŒæ­¥åŸ·è¡Œå–®å…ƒé–“çš„è³‡è¨Šï¼Œä¾‹å¦‚ shared memory æˆ– message passingã€‚
  2. èª¿ç¯€ï¼ˆCoordinationï¼‰ï¼šèª¿ç¯€åŸ·è¡Œå–®å…ƒé–“çš„åŸ·è¡Œé †åºï¼Œå¦‚ä½¿ç”¨ Semaphoresâ€Šç­‰å¾…åŸ·è¡Œç·’åŸ·è¡Œï¼Œæˆ–ä½¿ç”¨ proirity weight æ±ºå®šåŸ·è¡Œå…ˆå¾Œé †åºã€‚

> å¯¦éš›ä¸Š Synchronization å’Œ Coordination å¸¸å¸¸èåˆåœ¨ä¸€èµ·ï¼Œä¸æ˜“å€åˆ†ã€‚

---

class: middle, center

# Concurrency Model in Rust

---

## Threading Model

ç”±æ–¼ Rust æœ€åˆå®šä½åœ¨ system programming languageï¼Œæ‰€ä»¥

- æ²’æœ‰ green threadsï¼Œä¹Ÿä¸å­˜åœ¨ä»»ä½• lightweight threadsï¼Œ
- `std::thread` æœƒç”¢ç”Ÿ 1:1 çš„ OS thread èˆ‡ user threadã€‚

Threads ä¹‹é–“æºé€šå¯ä»¥é€é

- å…±äº«è¨˜æ†¶é«”çš„ synchronization primitivesï¼Œä¾‹å¦‚[æ‰€æœ‰ atomic é¡å‹][std-sync-atomic]ã€‚
- ç¨å¾®é«˜ç´šï¼Œä½†ä¾èˆŠåº•å±¤çš„ Synchronization Objectsï¼Œå¦‚ [`Mutex`][std-sync-mutex]ã€[`Condvar`][std-sync-condvar]ã€‚
- é‚„æœ‰å…§å»ºä½¿ç”¨ channel çš„ message passing æºé€šï¼Œä¸éåªæœ‰å–®ä¸€æ–¹å‘çš„ [`std::sync::mpsc`][std-sync-mpsc]ï¼ˆå¤šè¨Šæ¯ç”Ÿç”¢è€… producerï¼Œå–®ä¸€æ¥æ”¶è€… consumerï¼‰ã€‚


[std-sync-condvar]: https://doc.rust-lang.org/std/sync/struct.Condvar.html
[std-sync-mutex]: https://doc.rust-lang.org/std/sync/struct.Mutex.html
[std-sync-atomic]: https://doc.rust-lang.org/std/sync/atomic/index.html
[std-sync-mpsc]: https://doc.rust-lang.org/std/sync/mpsc/index.html

---

## ç°¡å–®çš„ thread æ“ä½œ

å»ºç«‹ä¸€å€‹ threadï¼ˆ`thread::spawn`ï¼‰

```rust
use std::thread;

thread::spawn(move || {
    // some work here
});
```

å»ºç«‹ä¸€å€‹ threadï¼Œä¸¦é€é JoinHandle ç­‰å¾… thread åŸ·è¡Œå®Œç•¢

```rust
use std::thread;

let child = thread::spawn(move || {
    // some work here
});
// some work here
let res = child.join();
```
---

## ç°¡å–®çš„ thread æ“ä½œ

- `std::thread::yield_now()`ï¼šæ”¾æ£„ç•¶å‰çš„ threadï¼Œé€šçŸ¥ OS scheduler åŸ·è¡Œå…¶ä»– threadã€‚é€šå¸¸æœƒé¿å…æ­¤æ“ä½œï¼Œæ”¹ç”¨ synchronization objectã€‚

- `std::thread::park()`ï¼šæš«åœç•¶å‰çš„ threadï¼Œå¯ä»¥å†å‘¼å« `std::thread::Thread::unpark(&self)` æ¢å¾©åŸ·è¡Œç·’é‹ä½œã€‚

---

## Borrow check in thread

Rust çš„ Concurrency Programming æ²’èƒ½æ“ºè„« borrow checker çš„é­”çˆªï¼Œä¾ç„¶æ´»åœ¨ lifetime çš„é™°å½±ä¹‹ä¸‹ä¸­ï¼Œå› æ­¤ï¼Œè³‡æ–™åœ¨ thread ä¹‹é–“çš„å‚³éå…±äº«ä»ç„¶å—**ã€Œå…±äº«ä¸å¯è®Šï¼Œå¯è®Šä¸å…±äº«ã€**çš„åŸå‰‡ä¿è­·ã€‚

---

### Borrow checker in thread

```rust
use std::thread;
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });
    drop(v); // oh no!
    handle.join().unwrap();
}
```

```
error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other 
referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
```

---

### Borrow checker in thread (add `move`)

```rust
use std::thread;
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });
    drop(v); // oh no!
    handle.join().unwrap();
}
```

```
error[E0382]: use of moved value: `v`
 --> src/main.rs:7:10
  |
4 |     let handle = thread::spawn(move || {
  |                                ------- value moved into closure here
5 |         println!("Here's a vector: {:?}", v);
  |                                           - variable moved due to use in closure
6 |     });
7 |     drop(v); // oh no!
  |          ^ value used here after move
```

---

### Borrow checker in thread (remove `drop`)

```rust
use std::thread;
fn main() {
    let v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });
    handle.join().unwrap();
}
```

---

### Borrow checker in thread (push values)

```rust
use std::thread;
fn main() {
    let mut v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        v.push(4);
    });
    handle.join().unwrap();
}
```

---

### Borrow checker in thread (push values)

```rust
use std::thread;
fn main() {
    let mut v = vec![1, 2, 3];
    let handle = thread::spawn(move || {
        v.push(4);
    });
    dbg!(&v);
    handle.join().unwrap();
}
```

```
error[E0382]: borrow of moved value: `v`
 --> src/main.rs:7:10
  |
4 |     let handle = thread::spawn(move || {
  |                                ------- value moved into closure here
  |         v.push(4);
  |         - variable moved due to use in closure
6 |     });
7 |     dbg!(&v);
  |          ^^ value borrowed here after move
  |
```

---

### Borrow checker in thread

ç„¡è«–æ˜¯åœ¨ single-threaded é‚„æ˜¯ multi-threaded çš„ç’°å¢ƒä¹‹ä¸‹ï¼š

_**The Rust compiler still prevents all data races.**_
---

## `Send` and `Sync` Traits


é™¤æ­¤ä¹‹å¤–ï¼ŒRust é‚„å®šç¾©äº†å…©å€‹ marker trait `Send` èˆ‡ `Sync`ï¼Œæœ‰ä»¥ä¸‹ç‰¹è‰²ï¼š

- æ”¾åœ¨ `std::marker` åº•ä¸‹ï¼Œè¡¨ç¤ºé€™åªæ˜¯çµ¦ç·¨è­¯å™¨çœ‹çš„æ¨™è¨»ï¼Œä¸éœ€æ‰‹å‹•å¯¦ä½œã€‚
- ç·¨è­¯å™¨æœƒè‡ªå‹•æ¨å°ï¼Œæ±ºå®šä½•æ™‚æ›¿ä½ çš„å‹åˆ¥æ·»åŠ å®ƒå€‘ï¼Œçµ•å¤§éƒ¨åˆ†ä¸éœ€è¦æ‰‹å‹•æ·»åŠ ã€‚

é€™å…©å€‹ trait æ±ºå®šäº†å‹åˆ¥èƒ½å¦è·¨åŸ·è¡Œç·’æºé€šï¼Œè€Œ borrow checker å‰‡æ±ºå®šäº†è·¨åŸ·è¡Œç·’çš„è®Šæ•¸æœƒä¸æœƒé€ æˆ Race conditionã€‚é€™å…©å€‹ feature å…±åŒæ‰“é€  Rust å¤šåŸ·è¡Œç·’ç¨‹å¼çš„å®‰å…¨å€ã€‚

---

### `Send`

1. å¯ä»¥åœ¨ thread ä¹‹é–“è½‰ç§»æ‰€æœ‰æ¬Šï¼ˆmove ownershipï¼‰çš„å‹åˆ¥ã€‚
2. å¦‚æœå¯è¡Œï¼Œç·¨è­¯å™¨æœƒè‡ªå‹•æ¨å°å¯¦ä½œã€‚
3. non-`Send` çš„ä¾‹å­æ˜¯ `Rc`
  - `Rc` åœ¨ thread é–“å‚³éæœƒå‘¼å« `Rc::clone`ï¼Œé€ æˆå¼•ç”¨è¨ˆæ•¸å¢åŠ ï¼Œä½†å¼•ç”¨è¨ˆæ•¸ä¸¦æ²’æœ‰ä½¿ç”¨åŸå­æ“ä½œï¼Œåœ¨å¤šåŸ·è¡Œç·’ç’°å¢ƒææœ‰èª¤ã€‚

```rust
impl<T: ?Sized> !marker::Send for Rc<T> {}

```

---

### `Sync`

1. å¯ä»¥åœ¨ thread ä¹‹é–“å…±äº«ï¼ˆborrowingï¼‰çš„å‹åˆ¥ã€‚
2. æ‰¿ä¸Šï¼Œè‹¥ `T` æ˜¯ `Sync`ï¼Œå‰‡ `&T` å°±æ˜¯ `Send`ã€‚
3. å¦‚æœå¯è¡Œï¼Œç·¨è­¯å™¨æœƒè‡ªå‹•æ¨å°å¯¦ä½œã€‚
4. non-`Sync` çš„ä¾‹å­æ˜¯ `Rc`ã€`Cell`ã€`RefCell` 
  - å…·æœ‰ã€Œ interior mutabilityã€ä½†ä¸ä½¿ç”¨åŸå­æ“ä½œçš„å‹åˆ¥ã€‚
  - `Rc` å¼•ç”¨è¨ˆæ•¸ä¸¦æ²’æœ‰ä½¿ç”¨åŸå­æ“ä½œï¼Œåœ¨å¤šåŸ·è¡Œç·’åŸ·è¡Œææœ‰èª¤ã€‚
  - `Cell`ã€`RefCell` å¯«å…¥ä¸éµå®ˆåŸå­æ“ä½œã€‚


```rust
impl<T: ?Sized> !marker::Sync for Rc<T> {}

impl<T: ?Sized> !Sync for Cell<T> {}

impl<T: ?Sized> !Sync for RefCell<T> {}
```

---

## `Send` and `Sync` Takeaways

- ä¸€èˆ¬é–‹ç™¼è€…çŸ¥é“é€™äº› trait çš„å‹åˆ¥å¯åœ¨åŸ·è¡Œç·’é–“çˆ½ç”¨å³å¯ï¼Œç·¨è­¯å™¨æœƒè‡ªå‹•æ¨å°ã€‚
- Concurrency library çš„é–‹ç™¼è€…æ‰éœ€è¦æ³¨æ„å¯¦ä½œ `Send` `Sync`
- ä»‹æ¥ FFI æ™‚å¯èƒ½è¦æ³¨æ„å‹åˆ¥æ˜¯å¦ç¬¦åˆï¼Œä¸è¡Œå°±è¦è‡ªå·±åŠ é¡ä¼¼çš„å¯¦ä½œï¼š 
  ```rust
  unsafe impl<T: ?Sized> !Send for MyExternalType {}
  ```

---

## Synchronization Primitives 

(a.k.a Atomic Type)

- å’Œ C++ ä¸€æ¨£ï¼ŒRust å®šç¾©äº†è¨±å¤šåŸºç¤å‹åˆ¥çš„ Atomic ç‰ˆæœ¬ï¼Œ
- æ¯” Rust std æä¾›çš„é–æ›´æœ‰æ•ˆåœ°å…±äº«è¨˜æ†¶é«”æºé€šã€‚
- `AtomicUsize`ï¼Œ`AtomicBool` ç­‰ `Atomic-` é–‹é ­çš„å‹åˆ¥éƒ½æ”¯æ´åŸå­æ“ä½œï¼Œ
- Atomic operationï¼šé€é[ç·¨è­¯å™¨ï¼ˆllvmï¼‰å®šç¾©çš„ memory model][llvm-memory-model]ï¼Œç”¢ç”Ÿç‰¹æ®Šçš„ CPU åŸå­æ“ä½œçš„æŒ‡ä»¤ï¼Œæ¦¨ä¹¾ CPU æœ€å¾Œä¸€é»æ€§èƒ½ã€‚
- [æŸ¥çœ‹æ›´å¤š][std-atomic]

[llvm-memory-model]: https://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations
[std-atomic]: https://doc.rust-lang.org/std/sync/atomic/index.html

---

## Synchronization Primitives 

ä¸€å€‹ç°¡å–®çš„è‡ªæ—‹é–ğŸ”’

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = spinlock.clone();
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // Wait for the other thread to release the lock
    while spinlock.load(Ordering::SeqCst) != 0 {}

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {:?}", panic);
    }
}
```

---

## Higher-level Synchronization Objects

Rust é‚„æä¾›è¼ƒé«˜éšï¼ˆä½†ä»ç„¶å¾ˆåº•å±¤ï¼‰çš„åŸ·è¡Œç·’åŒæ­¥æ“ä½œå‹åˆ¥ï¼Œç”±æ–¼å…§éƒ¨å‹åˆ¥ä¸éœ€è¦æ˜¯ Atomicï¼Œæ‰€ä»¥æœ‰è¼ƒé«˜çš„ runtime overheadã€‚

- `Arc`ï¼š`Rc` å¼•ç”¨è¨ˆæ•¸çš„åŸå­æ“ä½œç‰ˆæœ¬ã€‚
- `Mutex`ï¼šğŸ”’ äº’æ–¥é–ï¼Œé€é `lock` æ–¹æ³•å–å¾—å…§éƒ¨å‹åˆ¥ï¼Œdrop æ™‚è‡ªå‹• unlockã€‚
- `RwLock`ï¼šğŸ”’ è®€å¯«é–ï¼Œå’Œ `Mutex` é¡ä¼¼ï¼Œä¸éè®€èˆ‡å¯«å„æœ‰ `read` `write` ä¾†è™•ç†ï¼Œå¤šè®€å–å–®å¯«å…¥ã€‚
- `Barrier`ï¼šé›–ç„¶å«è·¯éšœï¼Œå¯ä»¥æƒ³åƒæˆé¤å»³è¨‚ä½ï¼Œäººæ•¸é”åˆ°æ‰æœƒæ”¾è¡Œï¼ˆåŸ·è¡Œåˆ° wait è™•çš„åŸ·è¡Œç·’è¶…éå®šé‡å°±æ”¾è¡Œï¼‰ã€‚
- `Condvar`ï¼šé˜»å¡åŸ·è¡Œç·’ä½†ä¸è€— CPU è³‡æºçš„æ¢ä»¶è®Šé‡ï¼Œé€šå¸¸å’Œ `Mutex` æˆå°å‡ºç¾ã€‚
- `Once`ï¼šç”¨ä¾†ç¢ºä¿å…¨åŸŸåˆå§‹åŒ–ç­‰æ“ä½œåªæœƒåŸ·è¡Œå”¯ä¸€ä¸€æ¬¡ï¼Œä¾‹å¦‚ singleton initializationã€‚
- `thread_local!`ï¼šä¸€å€‹ macroï¼Œé€éå®ƒç”¢ç”Ÿçš„è®Šæ•¸åœ¨æ¯å€‹åŸ·è¡Œç·’ä¸­éƒ½æ˜¯äº’ä¸å¹²æ“¾çš„ä¸€ä»½ copyã€‚
- `mpsc`ï¼šé€é channel ä»¥ FIFO queue å‚³é€è¨Šæ¯æºé€šï¼Œè€Œéå…±äº«è¨˜æ†¶é«”ï¼Œæ˜¯é€™äº›å‹åˆ¥ä¹‹ä¸­è¼ƒäººæ€§åŒ–çš„ APIï¼Œä¹‹å¾Œæœƒè©³ç´°ä»‹ç´¹ã€‚

---

### `Arc` + `Mutex`

å¦‚æœä¸€å€‹å–®åŸ·è¡Œç·’çš„ `Rc<RefCell<T>>` è¦æ”¹å¯«æ”¯æ´å¤šåŸ·è¡Œç·’ï¼Œå®šç¾©ç‚º

- `Arc<Mutex<T>>` æˆ–æ˜¯ 
- `Arc<RwLock<T>>` 

æ˜¯æœ€å®¹æ˜“çš„æ–¹å¼ã€‚

```rust
use std::sync::{Arc, Mutex};
use std::thread;

let mutex = Arc::new(Mutex::new(0));
let c_mutex = mutex.clone();

let join_handler = thread::spawn(move || {
    *c_mutex.lock().unwrap() = 10;
});
join_handler.join().expect("thread::spawn failed");
assert_eq!(*mutex.lock().unwrap(), 10);
```

---

class: middle, center

# Patterns of Concurrent Programming

<img src="https://www.developer.com/imagesvr_ce/8307/Actor3.jpg" width="500px">

---

## Patterns of Concurrent Programming

Concurrent programming æœ‰å¾ˆå¤šç¨®è¨­è¨ˆæ¨¡å¼èˆ‡å…¸ç¯„ï¼Œå‰é¢ä»‹ç´¹çš„ Synchronization primitives éƒ½æ˜¯åŸºæ–¼ shared-stateï¼Œé›–ç„¶å¥½ç†è§£ï¼Œä½†éš¨è‘—ç³»çµ±æ“´å¼µï¼Œå„ç¨®ç‹€æ…‹å¾€å¾€è¤‡é›œåˆ°é›£ä»¥ç®¡ç†ï¼Œå› æ­¤éœ€è¦æŠ½è±¡ç¨‹åº¦æ›´é«˜çš„è¨­è¨ˆæ¨¡å¼ï¼Œå°‡ç‹€æ…‹èˆ‡é‹ç®—è§£è€¦åˆã€‚

æ¥ä¸‹ä¾†ä»‹ç´¹å¸¸è¦‹çš„ä¸¦è¡Œç¨‹å¼è¨­è¨ˆæ¨¡å¼ã€‚

---

## Asynchronous Tasks

åˆå«åš future æˆ–æ˜¯ promiseï¼Œé‹ä½œé‚è¼¯å¦‚ä¸‹ï¼š

1. æä¾›ä¸€å€‹ proxy entityï¼ˆtaskï¼‰ï¼Œå°‡é‹ç®—èˆ‡å®ƒæœ€çµ‚çš„çµæœè§£è€¦åˆã€‚
2. ç•¶ task ç™¼é€å‡ºå»å¾Œï¼Œæœƒç›´æ¥è¿”å›ï¼Œè®“ caller ç¹¼çºŒå¾€ä¸‹åŸ·è¡Œï¼ˆå’Œçµæœè§£è€¦ï¼‰ã€‚
3. é‹ç®—çµæœä¸€å‡ºçˆï¼Œé€™å€‹ proxy å¯ä»¥è¢« poll æ‹‰å–å‡ºè©²çµæœã€‚
4. å¦‚æœçµæœå°šæœªæ­æ›‰ï¼Œproxy å¯ä»¥é˜»å¡ï¼Œæˆ–æ˜¯æä¾›é€šçŸ¥ä¸é˜»å¡ï¼ˆä¾å¯¦ä½œè€Œå®šï¼‰ã€‚

é€šå¸¸é€™äº› task çš„é‹ç®—æœƒåœ¨å¦ä¸€å€‹åŸ·è¡Œç·’ä¸­èª¿åº¦ï¼Œè®“æœ€åˆçš„åŸ·è¡Œç·’æŒçºŒå¾€ä¸‹é‹ä½œã€‚

- Actor-based system ä¸­çš„ actor é€šå¸¸å°±æ˜¯ä¸€å€‹é¡ä¼¼ future proxyã€‚
- Event-driven system ä¸­çš„ event ä¹Ÿæ˜¯é¡ä¼¼ future proxy çš„å­˜åœ¨ï¼Œé‹ç®—çµæœè¢« callback handler è™•ç†ã€‚

Rust æœ€è¿‘å¦‚ç«å¦‚è¼åœ¨è¨è«–çš„ feature ä¹‹ä¸€å°±æ˜¯ [future][std-future] èˆ‡ [async/await][std-async-await]ã€‚

[std-future]: https://github.com/aturon/rfcs/blob/async-trait/text/0000-async.md
[std-async-await]: https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md

---

## Actor-based

https://github.com/actix/actix

---

## Channels and Message Passing

- Channel å…©ç«¯åˆ†åˆ¥æ˜¯ `Sender` å’Œ `Receiver`ï¼Œäº’ç›¸é€é channel å‚³é€è¨Šæ¯ã€‚
- å¯ä»¥æ˜¯é›™å·¥ï¼Œæˆ–æ˜¯å–®å·¥ã€‚
- Rust çš„ `std::sync::mpsc` å¯¦éš›ä¸Šæ˜¯ä¸€å€‹å–®å·¥çš„ FIFO queue channelï¼Œå¤šå€‹ `Sender` å‚³é€è¨Šæ¯çµ¦ `Receiver`ã€‚
- `mpsc` å»ºç«‹å…©å€‹ channelï¼Œé€é[å‚³é sender å¯¦ç¾é›™å‘æºé€š](https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791)ã€‚

> Communicate by sharing (clones of) your Sender, and keep the Receiver to yourself.

---

## Event-driven

https://tokio.rs/

---

## Coroutines

- Coroutines å¯ä»¥è¦–ç‚º subroutine çš„ä¸€èˆ¬åŒ–ã€‚
- subroutine é€šå¸¸æ˜¯å¾ªåºåŸ·è¡Œï¼Œè€Œ coroutine å¯ä»¥æš«åœï¼ˆsuspendï¼‰ï¼Œä¸¦å¾æš«åœçš„ç¨‹å¼ä½ç½®æ¢å¾©ï¼ˆresumeï¼‰åŸ·è¡Œã€‚
- å¾ˆé©åˆ cooperative task handlingã€‚
- Coroutines é€šå¸¸è¢«ç•¶ä½œ low-level primitivesï¼Œå¯ä»¥ç”¨ä¾†æ§‹å»º event-driven æˆ– actor-based systemã€‚
- çŸ¥åçš„ [greenlet][greenlet] Python coroutine framework å°±æ˜¯ [gevent][gevent] event loop çš„ä½å±¤å¯¦ä½œã€‚
- è€Œ [May][may] å‰‡æ˜¯ Rust çš„ Stackful Coroutine Libraryã€‚

[greenlet]: https://greenlet.readthedocs.io/en/latest/
[gevent]: http://www.gevent.org/
[may]: https://github.com/Xudong-Huang/may

---

# Random Good Stuff

- [Rayon: A data parallelism library for Rust](https://github.com/rayon-rs/rayon)
- [crossbeam: Lock-free concurrent programming](https://github.com/crossbeam-rs/crossbeam)

---

# References

- Erb, B. (2012). [Concurrent programming for scalable web architectures][erb-con-web].
<!-- - Turon, A. (2015). [Lock-freedom without garbage collection][aturon-lock-free]. -->
<!-- - Glavina, S. (2019). [Lock-free Rust: Crossbeam in 2019][stjepang-lock-free]. -->
<!-- - wihtoutboats (2019). [Generators I: Toward a minimum viable product][withoutboats-generators-i]. -->
- Factotum, P. (2019). [Rust concurrency patterns: communicate by sharing your Sender][factotum-sharing-sender].
- Documentation of Rust Standard Library 1.32.0 (9fda7c223 2019-01-16).

[erb-con-web]: http://berb.github.io/diploma-thesis/community/index.html
[withoutblogs]: https://boats.gitlab.io/blog/
[aturon-lock-free]: https://aturon.github.io/blog/2015/08/27/epoch/
[stjepang-lock-free]: https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html
[withoutboats-generators-i]: https://boats.gitlab.io/blog/post/generators-i/ 
[factotum-sharing-sender]: https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791


---

class: middle, center

## AMA Time!

We are from

<img src="https://hahow.in/static/media/logo-black.23fa8b87.svg" width="250px" alt="Hahow å¥½å­¸æ ¡" />

Ask us anything!

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
